/*
 * ET4047 Homework 3.c
 *
 * Created: 11/12/2019 11:31:45
 * Author : Tanner Garity (19114141)
 */ 

/*
Question 1 - Setting an Additional Square Wave

HW2Q3.c (Rename as HW3Q1.c before releasing this) is a program that sets a 20 kHz square wave of OC1A of an ATMega328P microcontroller, clocked at 16MHz. 
Modify the program so that it also sets a 10 kHz square wave on OC1B of the microcontroller.
*/

#include <avr/io.h>
#include <avr/interrupt.h>

#define HALF_PERIOD 50
/* At 2MHz Timer 1 clock, 50 counts means 25 us, which is half of the 50us PERIOD  */
/* Note the T = 50us => f = 20kHz                                                  */


int main(void)
{
	DDRB = (1 << DDB1)|(1<<DDB2);			/* OC1A appears on PORTB Bit 1 and OC1B appears on PORTB Bit 2, so need to make both an output, so that OC1A and OC1B can drive both signals respectively */
	
	TCCR1B = (2 << CS10);		/* Clock source is now 16MHz/8 = 2MHz, same as writing TCCR1B = (1<<CS11) in order to set the prescaler to 8 */
	TCCR1A = (1 << COM1A0)|(1<<COM1B0);     /* COM1A1 = 0, COM1A0 = 1, COM1B1 = 0, and COM1B0 = 1 means toggle OC1A/OC1B on compare match, needs more */
	
	TIMSK1 = (1 << OCIE1A)|((1<<OCIE1B);		/* Enable interrupt on the OC1RA and OC1B compare match, */
	
	OCR1A = TCNT1 + HALF_PERIOD;	/* Not strictly necessary, because we'll hit the OCR1A value (whatever it is) eventually */
	OCR1B = TCNT1 + 100;  /* Not strictly necessary but this line incorporates the HACKPERIOD_10us variable that will be defined later in the program */
	
	sei();
	
	while (1)
	{
	}
}

#define HACK_PERIOD_10us 100 // f = 10 kHz; T=10*10^-3 = 100us; so 50us High and 50us Low; the AtMega328P is clocked at 0.5 so 50/0.5 = 100

ISR(TIMER1_COMPA_vect)
{
	OCR1A = OCR1A + HALF_PERIOD;	/* Next interrupt and toggle in HALF_PERIOD counts */
}
	
ISR(TIMER1_COMPB_vect)
{
	OCR1B = OCR1B + HACK_PERIOD_10us; /* Next interrupt and toggle in HACK_PERIOD_10us counts */
}
	
/*
Question 2 PWM Initialisation

HW2Q4.c ((Rename as HW3Q1.c before releasing this) is a program that sets up the ATMega328P so that the latest ADC reading sets the PWM output pulse, using OC2B of Timer/Counter2.

	(A)	A number of initialisation lines have been left out, ie setting of TCCR2A and TCCR2B. Fill these lines in for the following operation:
	
			Phase correct PWM mode with TOP value = 0xFF
			Clear OC2A on Compare Match when up-counting. Set OC2A on Compare Match when down-counting, (non-inverting mode)
			Clock Source set to be clkT2S/1024 (From prescaler)

	(B) By default the processor clock is set as clkT2s. Assuming that the processor clock frequency is 16MHz, what PWM frequency will be generated with these settings?
			The Power Wave Modulation frequency that is generated by the clock being set at clkT2s is 16*10^6/(1024*510) = 31 Hz
*/

#include <avr/io.h>
#include <avr/interrupt.h>

int main(void)
{
	DDRB = 0b00001000;		/* 0x08 Expressed as a binary value and this line is necessary since OC2A is shared with bit three */
	
	TCCR2A = 0b10000001; /* WGM22 = 0, WGM21 = 0, and WGM20 = 1 Sets the Phase Correct PWM Mode with a top value of 0xFF;
	 COM2A1 = 1 and COM2A0 = 0 in order to Clear OC2A on Compare Match when up-counting and to set OC2A on Compare Match when down-counting*/
	TCCR2B = 0b00000111; /* CA22 = 1, CA21 = 1, and CS20 = 1 because the prescaler is to be set to 1024, WGM22 = 0 is set in this register */
	
	OCR2A = 0;					/* Initial setting  */
	
	ADMUX = (1 << REFS0) | (0 << MUX0);			/* AVCC (5V) set as VRef, ADC0 selected as input V to ADC  */
	ADCSRA = (1 << ADEN) | (1 << ADSC) | (1 << ADATE) | (1 << ADIE) | (7 << ADPS0);
	/* ADC Enabled, ADC Conversion started (ADSC), Auto Trigger Enabled, Clk/128 is ADC clk */
	/* We use Free Run mode, but we do need to start the first conversion  */
	ADCSRB = (0 << ADTS0);					/* ADC Conversion complete (ADIF) retriggers a conversion  */
	
	sei();									/* Global Interrupt Enable after other interrupt initialisation */
	
	while(1)
	;
}

ISR(ADC_vect)
{
	int adc_value;
	
	adc_value = ADC;
	
	adc_value = adc_value >> 2;			/* OCR2A is just 8-bits, so we reduce no of bits to 8 by 2 right shifts  */
	
	OCR2A = (unsigned char)adc_value;	/* New OCR2A value from ADC reading  */
}



/*
Question 3 Serial Port and Buad Rate From the EE4524 2017 Exam

(i) Given an ATMega328P microcontroller with a 10 MHz clock, calculate the value to be written to the UBRR register, to select a Baud Rate of 115200 Baud, assuming that Double Speed mode is selected.
	The UBRRn value that is written to the UBRR register is 10 which is approximatly 10*10^6/(8*115200) due the fact that the value must be a rounded integer.
(ii) Calculate the % error from the ideal baud rate that will result from the UBRR0 value you have found.
	The percent error between the Closest match Baud Rate and the Ideal Baud Rate is -1.36% which is calculated by first calculating the Closest Match Buad Rate = 113636 = 10*10^6/(8*11), and then by calculating the percent error = -1.36% = (113636/115200 - 1)
*/
